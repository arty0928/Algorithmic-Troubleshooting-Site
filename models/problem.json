[
    {
        "id": 1,
        "header": {
            "title": "습격자 초라기",
            "rank": "platinum3",
            "source": "baekjoon",
            "problemId": "1006번",
            "link": "https://www.acmicpc.net/problem/1006"
        },
        "content": {
            "description": "<div id=\"problem_description\" class=\"problem-text\">\n\t\t\t\t<p>초라기는 한국의 비밀국방기지(원타곤)를 습격하라는 임무를 받은 특급요원이다. 원타곤의 건물은 도넛 형태이며, 초라기는 효율적인 타격 포인트를 정하기 위해 구역을 아래와 같이 두 개의 원 모양으로 나누었다. (그림의 숫자는 각 구역의 번호이다.)</p>\n\n<p style=\"text-align: center;\"><img alt=\"\" src=\"https://www.acmicpc.net/upload/201003/dfck3232_34g7t9f4gp_b.jpg\" style=\"height:320px; width:320px\"></p>\n\n<p>초라기는 각각 W명으로 구성된 특수소대를 다수 출동시켜 모든 구역에 침투시킬 예정이며, 각 구역 별로 적이 몇 명씩 배치되어 있는지는 초라기가 모두 알고 있다. 특수소대를 아래 조건에 따라 침투 시킬 수 있다.</p>\n\n<ol>\n\t<li>한 특수소대는 침투한 구역 외에, 인접한 한 구역 더 침투할 수 있다. (같은 경계를 공유하고 있으면 인접 하다고 한다. 위 그림에서 1구역은 2, 8, 9 구역과 서로 인접한 상태다.) 즉, 한 특수소대는 한 개 혹은 두 개의 구역을 커버할 수 있다.</li>\n\t<li>특수소대끼리는 아군인지 적인지 구분을 못 하기 때문에, 각 구역은 하나의 소대로만 커버해야 한다.</li>\n\t<li>한 특수소대가 커버하는 구역의 적들의 합은 특수소대원 수 W 보다 작거나 같아야 한다.</li>\n</ol>\n\n<p>이때 초라기는 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 알고 싶어 한다.</p>\n\n\t\t\t\t</div>",
            "input_description": "<div id=\"problem_input\" class=\"problem-text\">\n\t\t\t\t\t<p>첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 구성되어있다.</p>\n\n<p>첫째 줄에는 (구역의 개수)/2 값 N과 특수 소대원의 수 W가 주어진다. (1 ≤ N ≤ 10000, 1 ≤ W ≤ 10000).</p>\n\n<p>둘째 줄에는 1~N번째 구역에 배치된 적의 수가 주어지고, 셋째 줄에는 N+1 ~ 2N번째 구역에 배치된 적의 수가 공백으로 구분되어 주어진다. (1 ≤ 각 구역에 배치된 최대 적의 수 ≤ 10000) 단, 한 구역에서 특수 소대원의 수보다 많은 적이 배치된 구역은 존재하지 않는다. (따라서, 각 구역에 배치된 최대 적의 수 ≤ W)</p>\n\n\t\t\t\t\t</div>",
            "output_description": "<div id=\"problem_output\" class=\"problem-text\">\n\t\t\t\t\t<p>각 테스트케이스에 대해서 한 줄에 하나씩 원타곤의 모든 구역을 커버하기 위해 침투 시켜야 할 특수 소대의 최소 개수를 출력하시오.</p>\n\n\t\t\t\t\t</div>",
            "input_example": "1\n8 100\n70 60 55 43 57 60 44 50\n58 40 47 90 45 52 80 40",
            "output_example": "11",
            "author": "wooyaggo"
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 2,
        "header": {
            "title": "종이 레이싱",
            "rank": "diamond5",
            "source": "baekjoon",
            "problemId": "1130번",
            "link": "https://www.acmicpc.net/problem/1130"
        },
        "content": {
            "description": "<div id=\"problem_description\" class=\"problem-text\">\r\n\t\t\t\t<p>종혁이와 재홍이는 종이 레이싱을 즐긴다. 트랙은 종이를 정사각형으로 나눈 것이다. 각 칸은 도로 또는 장애물이다. 두 개의 도로는 시작과 끝으로 표시되어져 있다. 이 게임의 목표는 시작에서 차를 출발시켜서 끝으로 최대한 빨리 이동시키는 것이다.</p>\r\n\r\n<p>이 게임에서 차는 점 하나로 표시된다. 움직임은 각 턴으로 움직인다. 각 턴의 시작에 차는 어떤 칸의 중심에 있다. 그리고 각 턴의 움직임은 다른 칸의 중심으로 이동하는 것이다. 차의 속도는 정수 좌표를 가진 벡터이다. 각 턴은 다음과 같이 이루어져 있다.</p>\r\n\r\n<ol>\r\n\t<li>이번 턴이 시작하기 바로 전에 차의 속도를 바꿀 수 있는데, 속도의 각 좌표를 1씩 증가시키거나, 1씩 감소시키거나, 그대로 놔둘 수 있다. (두 좌표를 같이 증가시키거나, 감소시켜야 하는 것은 아니다. 서로 다른 연산을 할 수 있다.)</li>\r\n\t<li>차를 움직인다. 만약 차가 (r, c)에 있고, 차의 속도가 (vr, vc)라면, 차가 이동하는 새로운 좌표는 (r+vr, c+vc)이다. 차는 이전에 있던 칸의 중심과, 새로운 칸의 중심을 이은 직선을 따라 이동한다.</li>\r\n</ol>\r\n\r\n<p>만약 차의 이동 경로가 끝이 쓰여 있는 도로를 지난다면, 게임은 즉시 끝이 나고, 그때 까지의 턴의 개수가 이동한 시간이 된다. 만약 차의 경로가 게임이 끝나기 전에 장애물을 지난다면, 차는 부수어지고, 게임을 끝마칠 수 없게 된다. (차는 장애물을 스칠 수 있다)</p>\r\n\r\n<p>차는 종이를 벗어날 수 없다. (종이를 벗어나면 실격처리 된다)</p>\r\n\r\n<p>만약 차가 이동하는 곳의 위치가 장애물이거나, 종이 밖이라고 해도, 그 전에 끝을 통과한다면, 게임은 성공적으로 끝난다.</p>\r\n\r\n<p>종이의 모양과 vr, vc가 주어졌을 때, 게임을 끝내는데 드는 턴의 최솟값을 구하는 프로그램을 작성하시오. 만약 끝까지 가는 것이 불가능하다면 -1을 출력한다.</p>\r\n\r\n\t\t\t\t</div>",
            "input_description": "<div id=\"problem_input\" class=\"problem-text\">\r\n\t\t\t\t\t<p>첫째 줄에 N과 M이 주어진다. 둘째 줄부터 N개의 줄에 종이의 모양이 주어진다. ‘.’은 도로, ‘S’는 시작, ‘F’는 끝, ‘X’는 장애물이다. 마지막 줄에는 vr과 vc가 주어진다. N과 M은 50보다 작거나 같은 자연수이고, vr과 vc는 절댓값이 50보다 작거나 같은 정수이다. 종이에 S와 F는 항상 하나만 있다.</p>\r\n\r\n\t\t\t\t\t</div>",
            "output_description": "<div id=\"problem_output\" class=\"problem-text\">\r\n\t\t\t\t\t<p>첫째 줄에 문제의 정답을 출력한다.</p>\r\n\r\n\t\t\t\t\t</div>",
            "input_example": "5 2\r\nFX\r\nX.\r\n.X\r\nX.\r\nSX\r\n1 0",
            "output_example": "8",
            "author": "baekjoon"
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 3,
        "header": {
            "title": "초콜릿 쪼개기 게임",
            "rank": "platinum1",
            "source": "baekjoon",
            "problemId": "22850번",
            "link": "https://www.acmicpc.net/problem/22850"
        },
        "content": {
            "description": "<div id=\"problem_description\" class=\"problem-text\">\n\t\t\t\t<p>서현과 현서는 <em>N</em> × <em>M</em> 격자 모양의 초콜릿을 쪼개 먹으려고 한다. 하지만 커다란 초콜릿을 쪼개는 일은 너무 지루해서 둘은 게임을 하려고 한다.</p>\n\n<p>게임은 서현부터 시작하여 번갈아가면서 턴을 진행한다. 자신의 턴이 되면 초콜릿 조각 중 하나를 고르고, 그 조각에서 가로줄 또는 세로줄 하나를 고른다. 단, 맨 위나 아래 가로줄, 또는 맨 왼쪽이나 오른쪽 세로줄은 고를 수 없다. 그 후 고른 줄을 먹고 초콜릿을 나머지 두 조각으로 쪼갠다. 자신의 턴에 행동을 할 수 없는 플레이어가 패배하게 된다. </p>\n\n<p>초콜릿이 너무나 커다란 나머지 둘은 게임을 하는 것에도 지쳐버렸다. 만약 둘 모두 최선의 전략을 사용한다면 누가 이기게 될지 서현과 현서를 대신하여 구해주자!</p>\n\n\t\t\t\t</div>",
            "input_description": "<div id=\"problem_input\" class=\"problem-text\">\n\t\t\t\t\t<p>초콜릿의 세로 길이 <em>N</em>과 가로 길이 <em>M</em>이 공백을 구분으로 차례로 주어진다. </p>\n\n\t\t\t\t\t</div>",
            "output_description": "<div id=\"problem_output\" class=\"problem-text\">\n\t\t\t\t\t<p>서현이 이기게 된다면 sh을 현서가 이기게 된다면 hs를 출력한다. </p>\n\n\t\t\t\t\t</div>",
            "input_example": "3 3",
            "output_example": "sh",
            "author": "stonejjun03"
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 4,
        "header": {
            "title": "",
            "rank": "",
            "source": "",
            "problemId": "",
            "link": ""
        },
        "content": {
            "description": "",
            "input_description": "",
            "output_description": "",
            "input_example": "",
            "output_example": "",
            "author": ""
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 5,
        "header": {
            "title": "",
            "rank": "",
            "source": "",
            "problemId": "",
            "link": ""
        },
        "content": {
            "description": "",
            "input_description": "",
            "output_description": "",
            "input_example": "",
            "output_example": "",
            "author": ""
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 6,
        "header": {
            "title": "",
            "rank": "",
            "source": "",
            "problemId": "",
            "link": ""
        },
        "content": {
            "description": "",
            "input_description": "",
            "output_description": "",
            "input_example": "",
            "output_example": "",
            "author": ""
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 7,
        "header": {
            "title": "",
            "rank": "",
            "source": "",
            "problemId": "",
            "link": ""
        },
        "content": {
            "description": "",
            "input_description": "",
            "output_description": "",
            "input_example": "",
            "output_example": "",
            "author": ""
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 8,
        "header": {
            "title": "",
            "rank": "",
            "source": "",
            "problemId": "",
            "link": ""
        },
        "content": {
            "description": "",
            "input_description": "",
            "output_description": "",
            "input_example": "",
            "output_example": "",
            "author": ""
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 9,
        "header": {
            "title": "",
            "rank": "",
            "source": "",
            "problemId": "",
            "link": ""
        },
        "content": {
            "description": "",
            "input_description": "",
            "output_description": "",
            "input_example": "",
            "output_example": "",
            "author": ""
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 10,
        "header": {
            "title": "",
            "rank": "",
            "source": "",
            "problemId": "",
            "link": ""
        },
        "content": {
            "description": "",
            "input_description": "",
            "output_description": "",
            "input_example": "",
            "output_example": "",
            "author": ""
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 11,
        "header": {
            "title": "",
            "rank": "",
            "source": "",
            "problemId": "",
            "link": ""
        },
        "content": {
            "description": "",
            "input_description": "",
            "output_description": "",
            "input_example": "",
            "output_example": "",
            "author": ""
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 12,
        "header": {
            "title": "",
            "rank": "",
            "source": "",
            "problemId": "",
            "link": ""
        },
        "content": {
            "description": "",
            "input_description": "",
            "output_description": "",
            "input_example": "",
            "output_example": "",
            "author": ""
        },
        "solution": {
            "code": ""
        }
    },
    {
        "id": 13,
        "header": {
            "title": "",
            "rank": "",
            "source": "",
            "problemId": "",
            "link": ""
        },
        "content": {
            "description": "",
            "input_description": "",
            "output_description": "",
            "input_example": "",
            "output_example": "",
            "author": ""
        },
        "solution": {
            "code": ""
        }
    }
]